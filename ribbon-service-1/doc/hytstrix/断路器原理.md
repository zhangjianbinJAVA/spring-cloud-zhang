###hystrix 如何决策熔断和记录信息呢？
```
public interface HystrixCircuitBreaker {

    public boolean allowRequest();
   
    public boolean isOpen();

    void markSuccess();

    public static class Factory {
            private static ConcurrentHashMap<String, HystrixCircuitBreaker> circuitBreakersByCommand 
            = new ConcurrentHashMap<String, HystrixCircuitBreaker>();
    }
    
    static class NoOpCircuitBreaker implements HystrixCircuitBreaker{}
    
    static class HystrixCircuitBreakerImpl implements HystrixCircuitBreaker {
    
    private final HystrixCommandProperties properties;//HystrixCommand实例的属性 
    private final HystrixCommandMetrics metrics; //HystrixCommand记录各类度量指标
    private AtomicBoolean circuitOpen = new AtomicBoolean(false);//断路器是否打开
    private AtomicLong circuitOpenedOrLastTestedTime = new AtomicLong();//断器路打开时的时间戳
    
    }
 }
```

- allowRequest() 每个hystrix 命令的请求都通过它判断是否被执行
- isOpen() 返回当前断路器是否打开
- markSuccess() 用来闭合断路器
- Factory 维护 hystrix 与HystrixCircuitBreaker的关系，key通过HystrixCommandKey定义
- NoOpCircuitBreaker 断路器始终闭合
- HystrixCircuitBreakerImpl 断路器实现

####isOpen() 判断断路器的打开或关闭状态
```
@Override
        public boolean isOpen() {
            if (circuitOpen.get()) {    
                return true;
            }          
            HealthCounts health = metrics.getHealthCounts();  
            if (health.getTotalRequests() < properties.circuitBreakerRequestVolumeThreshold().get()) {              
                return false;
            }
            if (health.getErrorPercentage() < properties.circuitBreakerErrorThresholdPercentage().get()) {
                return false;
            } else {              
                if (circuitOpen.compareAndSet(false, true)) {                  
                    circuitOpenedOrLastTestedTime.set(System.currentTimeMillis());
                    return true;
                } else {                   
                    return true;
                }
            }
        }
```
- 如果断路器打开，则直接返回true,否则通过 HealthCounts 统计对象做进一步的判断，
该对象记录了一个滚动时间窗内的请求信息快照，默认时间窗为10秒

- QPS :即每秒的响应请求数，也即是最大吞吐能力。

- 如果它的请求总数(QPS) 在预设的阈值范围内就返回false,表示断路器处于未打开状态，
  该阈值参数为 circuitBreakerRequestVolumeThreshold 默认值为20
    
- 如果错误百分比在阈值范围内就返回false,表示断路器处于未打开状态，
  该阈值参数为 circuitBreakerErrorThresholdPercentage 默认值为 50
  
  也就是说 10秒内统计20个请求这是有问题的，10秒内超过 50% 的请求是失败的就 打开断路器
  
如果上面的两个条件都不满足，则将断路器设置为打开关态，同时，如果是从关闭状态切换到打开状态的话，
就将当前时间记录到 circuitOpenedOrLastTestedTime 对象中

- allowRequest() 判断请求是否被允许
```
     @Override
        public boolean allowRequest() {
            if (properties.circuitBreakerForceOpen().get()) {  //断路器强制打开           
                return false; //拒绝请求
            }
            if (properties.circuitBreakerForceClosed().get()) {              
                isOpen();              
                return true;
            }
            
            return !isOpen() || allowSingleTest();
        }

     allowSingleTest() 做什么的？     
     public boolean allowSingleTest() {
            long timeCircuitOpenedOrWasLastTested = circuitOpenedOrLastTestedTime.get();
            
            //当断路器打开时，会判断 断开时的时间戳 + 配置中的时间是否小于当前时间 
            if (circuitOpen.get() && System.currentTimeMillis() 
            > timeCircuitOpenedOrWasLastTested + properties.circuitBreakerSleepWindowInMilliseconds().get()) {               
                
                //将当前时间记录更新到 记录断路器打开的时间对象 circuitOpenedOrLastTestedTime 中并且允许此次请求
                
                //通过 circuitBreakerSleepWindowInMilliseconds 参数设置了一个断路器打开之后的休眠时间 默认5秒
                
                //在该休眠时间到达之后，将再次允许请求尝试访问，此时断器处于 半开 状态，若此时请求继续失败，断路器又进入打开状态
                                
                if (circuitOpenedOrLastTestedTime.compareAndSet(timeCircuitOpenedOrWasLastTested, System.currentTimeMillis())) {                    
                    return true;
                }
            }
            return false; 
        }
```

- markSuccess() 用于在 半开路 状态时，若 hystrix 命令调用成功，通过调用它将打开的断器关闭，并重置度量指标对象
```
    public void markSuccess() {
            if (circuitOpen.get()) {
                if (circuitOpen.compareAndSet(true, false)) {                   
                    metrics.resetStream();
                }
            }
        }
```


###断路器的详细执行逻辑
![img_text](./img/断路器逻辑.png)

####依赖隔离 指服务的依赖隔离
docker 通过 舱壁模式，实现进程的隔离，使得容器与容器之间不会互相影响

hystrix 则使用该模式实现线程池的隔离，它会为每一个依赖服务创建一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只是对该
服务的调用产生影响，而不会拖慢其他的依赖服务

#### hystrix 性指测试
命令以每秒60 个请求的速度（QPS）对单一个服务实例进行访问，该服务实例每秒运行的线程数峰值为 350个
99%的情况下，使用线程池隔离的延迟有9ms

#### 信号量
hystrix 除了可使用线程池，还可以命命使用信号量来控制单个依赖服务的并发度，信号量的开销远比线程池的开销小，
但是它不能设置 超时 和实现 异步 访问
- 隔离策略参数：execution.isolation.strategy   THREAD 线程池 SEMAPHORE 信号量
- 信号量的默认值为 10，可以动态刷新配置方式来控制并发线程的数量
- 请求耗时在 1ms 以内，性能可达到 5000rps(rps指每秒的请求数)，可以将信息号设置为 1 或 2

#### 不用实现降级逻辑
- 执行写操作的命令,因为通常情况下，这类操作的返回类型是 void 
- 执行批处理或离线计算命令 

#### 不论hystrix命令是否实现了服务降级，命令状态和断路器状态都会更新


#### 断路器是否打开 相关逻辑判断
```
/**
     * Whether the 'circuit-breaker' is open meaning that <code>execute()</code> will immediately return
     * the <code>getFallback()</code> response and not attempt a HystrixCommand execution.
     *
     * ForcedOpen | ForcedClosed | CircuitBreaker open due to health ||| Expected Result
     *
     * T | T | T ||| OPEN (true)
     * T | T | F ||| OPEN (true)
     * T | F | T ||| OPEN (true)
     * T | F | F ||| OPEN (true)
     * F | T | T ||| CLOSED (false)
     * F | T | F ||| CLOSED (false)
     * F | F | T ||| OPEN (true)
     * F | F | F ||| CLOSED (false)
     *
     * @return boolean
     */
    public boolean isCircuitBreakerOpen() {
        return properties.circuitBreakerForceOpen().get() || (!properties.circuitBreakerForceClosed().get() && circuitBreaker.isOpen());
    }
```